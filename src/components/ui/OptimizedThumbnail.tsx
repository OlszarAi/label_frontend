import React, { useState, useCallback, useRef, useEffect } from 'react';
import { useOptimizedThumbnail, OptimizedWorkspaceService } from '@/services/optimizedWorkspace.service';
import { Image, RefreshCw } from 'lucide-react';

interface OptimizedThumbnailProps {
  labelId: string;
  thumbnailUrl?: string | null; // Direct thumbnail URL to avoid API calls
  size?: 'sm' | 'md' | 'lg';
  alt?: string;
  className?: string;
  fallback?: React.ReactNode;
  onLoad?: () => void;
  onError?: () => void;
  enableIntersectionObserver?: boolean;
  generateOnError?: boolean;
}

/**
 * Optimized thumbnail component with caching, lazy loading, and auto-generation
 */
export const OptimizedThumbnail: React.FC<OptimizedThumbnailProps> = ({
  labelId,
  thumbnailUrl: providedThumbnailUrl,
  size = 'md',
  alt,
  className = '',
  fallback,
  onLoad,
  onError,
  enableIntersectionObserver = true,
  generateOnError = false
}) => {
  const [isIntersecting, setIsIntersecting] = useState(!enableIntersectionObserver);
  const [imageError, setImageError] = useState(false);
  const [generating, setGenerating] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  // Use provided thumbnail URL or fetch from API if not provided
  const shouldFetchFromApi = !providedThumbnailUrl && isIntersecting;
  
  const {
    data: fetchedThumbnailUrl,
    loading,
    error,
    refresh
  } = useOptimizedThumbnail(labelId, size, shouldFetchFromApi);

  // Use provided URL or fetched URL
  const thumbnailUrl = providedThumbnailUrl || fetchedThumbnailUrl;

  // Intersection Observer for lazy loading
  useEffect(() => {
    if (!enableIntersectionObserver || !containerRef.current) return;

    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsIntersecting(true);
          observer.disconnect();
        }
      },
      {
        threshold: 0.1,
        rootMargin: '50px'
      }
    );

    observer.observe(containerRef.current);

    return () => observer.disconnect();
  }, [enableIntersectionObserver]);

  // Handle image load
  const handleImageLoad = useCallback(() => {
    setImageError(false);
    onLoad?.();
  }, [onLoad]);

  // Handle image error
  const handleImageError = useCallback(async () => {
    setImageError(true);
    onError?.();

    // Don't try to regenerate thumbnails - this causes infinite loops when backend returns 404
    // The thumbnails should be generated by the backend when labels are created
    console.log(`üñºÔ∏è Thumbnail not available for label ${labelId}`);
    
    // IMPORTANT: Do not call refresh() here - it causes infinite loops!
  }, [onError, labelId]);

  // Manual refresh function
  const handleRefresh = useCallback(async () => {
    setImageError(false);
    setGenerating(true);
    try {
      await refresh();
    } finally {
      setGenerating(false);
    }
  }, [refresh]);

  // Determine what to render
  const renderContent = () => {
    // Loading state
    if (loading || generating) {
      return (
        <div className={`thumbnail-loading ${className}`}>
          <div className="loading-spinner">
            <RefreshCw className="animate-spin" size={16} />
          </div>
          {loading && <span className="loading-text">Loading...</span>}
          {generating && <span className="loading-text">Generating...</span>}
        </div>
      );
    }

    // Error state or no thumbnail
    if (error || imageError || !thumbnailUrl) {
      if (fallback) {
        return fallback;
      }

      return (
        <div className={`thumbnail-placeholder ${className}`}>
          <div className="placeholder-content">
            <Image size={24} className="placeholder-icon" />
            <span className="placeholder-text">No Preview</span>
            {generateOnError && (
              <button 
                onClick={handleRefresh}
                className="generate-btn"
                disabled={generating}
              >
                Generate
              </button>
            )}
          </div>
        </div>
      );
    }

    // Success state
    return (
      <img
        ref={imgRef}
        src={thumbnailUrl}
        alt={alt || `Thumbnail for label ${labelId}`}
        className={`thumbnail-image ${className}`}
        onLoad={handleImageLoad}
        onError={handleImageError}
        loading="lazy"
      />
    );
  };

  return (
    <div 
      ref={containerRef}
      className={`optimized-thumbnail ${size} ${loading ? 'loading' : ''} ${error ? 'error' : ''}`}
    >
      {renderContent()}
    </div>
  );
};

// CSS-in-JS styles (you can move these to a CSS file)
const thumbnailStyles = `
  .optimized-thumbnail {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--color-gray-50);
    border-radius: 8px;
    overflow: hidden;
    transition: all 0.2s ease-in-out;
  }

  .optimized-thumbnail.sm {
    width: 60px;
    height: 60px;
  }

  .optimized-thumbnail.md {
    width: 120px;
    height: 120px;
  }

  .optimized-thumbnail.lg {
    width: 200px;
    height: 200px;
  }

  .thumbnail-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: opacity 0.2s ease-in-out;
  }

  .thumbnail-loading,
  .thumbnail-placeholder {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: var(--color-gray-100);
    color: var(--color-gray-500);
    gap: 8px;
  }

  .loading-spinner {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .loading-text,
  .placeholder-text {
    font-size: 12px;
    font-weight: 500;
    text-align: center;
  }

  .placeholder-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }

  .placeholder-icon {
    opacity: 0.5;
  }

  .generate-btn {
    padding: 4px 8px;
    font-size: 10px;
    background: var(--color-primary-500);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
  }

  .generate-btn:hover {
    background: var(--color-primary-600);
  }

  .generate-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .optimized-thumbnail:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  .optimized-thumbnail.loading {
    animation: pulse 1.5s ease-in-out infinite;
  }
`;

// Inject styles (in a real app, these would be in a CSS file)
if (typeof document !== 'undefined') {
  const styleSheet = document.createElement('style');
  styleSheet.textContent = thumbnailStyles;
  document.head.appendChild(styleSheet);
}

// Export hook for programmatic thumbnail management
export const useThumbnailGenerator = () => {
  const generateThumbnail = useCallback(async (
    labelId: string, 
    canvasDataURL: string, 
    size: 'sm' | 'md' | 'lg' = 'md'
  ) => {
    try {
      const result = await OptimizedWorkspaceService.generateThumbnail(labelId, canvasDataURL, size);
      if (result) {
        console.log(`‚úÖ Generated thumbnail for label ${labelId} (${size})`);
        return result;
      }
      return null;
    } catch (error) {
      console.error(`‚ùå Failed to generate thumbnail for label ${labelId}:`, error);
      return null;
    }
  }, []);

  const batchGenerateThumbnails = useCallback(async (
    labelData: Array<{ labelId: string; canvasDataURL: string }>
  ) => {
    const results = await Promise.allSettled(
      labelData.map(({ labelId, canvasDataURL }) => 
        generateThumbnail(labelId, canvasDataURL)
      )
    );

    const successful = results.filter(r => r.status === 'fulfilled').length;
    console.log(`üìä Batch thumbnail generation: ${successful}/${results.length} successful`);

    return results;
  }, [generateThumbnail]);

  return {
    generateThumbnail,
    batchGenerateThumbnails
  };
};
