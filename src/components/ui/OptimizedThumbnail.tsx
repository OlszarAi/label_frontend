import React, { useState, useCallback, useRef, useEffect } from 'react';
import NextImage from 'next/image';
import { useOptimizedThumbnail, OptimizedWorkspaceService } from '@/services/optimizedWorkspace.service';
import { Image, RefreshCw } from 'lucide-react';

interface OptimizedThumbnailProps {
  labelId: string;
  thumbnailUrl?: string | null; // Direct thumbnail URL to avoid API calls
  size?: 'sm' | 'md' | 'lg';
  alt?: string;
  className?: string;
  fallback?: React.ReactNode;
  onLoad?: () => void;
  onError?: () => void;
  enableIntersectionObserver?: boolean;
  generateOnError?: boolean;
  // New props for dynamic sizing based on label dimensions
  labelWidth?: number; // in mm
  labelHeight?: number; // in mm
  maxWidth?: number; // max container width in px
  maxHeight?: number; // max container height in px
  maintainAspectRatio?: boolean;
}

/**
 * Optimized thumbnail component with caching, lazy loading, and auto-generation
 */
export const OptimizedThumbnail: React.FC<OptimizedThumbnailProps> = ({
  labelId,
  thumbnailUrl: providedThumbnailUrl,
  size = 'md',
  alt,
  className = '',
  fallback,
  onLoad,
  onError,
  enableIntersectionObserver = true,
  generateOnError = false,
  labelWidth = 100,
  labelHeight = 50,
  maxWidth,
  maxHeight,
  maintainAspectRatio = true
}) => {
  const [isIntersecting, setIsIntersecting] = useState(!enableIntersectionObserver);
  const [imageError, setImageError] = useState(false);
  const [generating, setGenerating] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  // Calculate container dimensions based on label aspect ratio
  const getContainerDimensions = useCallback(() => {
    if (!maintainAspectRatio) {
      // Use default fixed sizes if not maintaining aspect ratio
      const sizeMap = { sm: 60, md: 120, lg: 200 };
      const fixedSize = sizeMap[size];
      return { width: fixedSize, height: fixedSize };
    }

    const aspectRatio = labelWidth / labelHeight;
    
    // Get base dimensions for each size
    const baseDimensions = {
      sm: { width: 80, height: 60 },
      md: { width: 200, height: 150 },
      lg: { width: 300, height: 200 }
    };

    const base = baseDimensions[size];
    
    // Apply custom max dimensions if provided
    const maxW = maxWidth || base.width;
    const maxH = maxHeight || base.height;
    
    // Calculate dimensions maintaining aspect ratio
    let width = maxW;
    let height = width / aspectRatio;
    
    // If height exceeds max, constrain by height
    if (height > maxH) {
      height = maxH;
      width = height * aspectRatio;
    }
    
    // Ensure minimum dimensions for very small labels
    const minSize = size === 'sm' ? 40 : size === 'md' ? 80 : 120;
    if (width < minSize && height < minSize) {
      if (aspectRatio > 1) {
        width = minSize;
        height = minSize / aspectRatio;
      } else {
        height = minSize;
        width = minSize * aspectRatio;
      }
    }
    
    return { 
      width: Math.round(width), 
      height: Math.round(height),
      aspectRatio 
    };
  }, [labelWidth, labelHeight, size, maxWidth, maxHeight, maintainAspectRatio]);

  const containerDimensions = getContainerDimensions();

  // Use provided thumbnail URL or fetch from API if not provided
  const shouldFetchFromApi = !providedThumbnailUrl && isIntersecting;
  
  const {
    data: fetchedThumbnailUrl,
    loading,
    error,
    refresh
  } = useOptimizedThumbnail(labelId, size, shouldFetchFromApi);

  // Use provided URL or fetched URL
  const thumbnailUrl = providedThumbnailUrl || fetchedThumbnailUrl;

  // Intersection Observer for lazy loading
  useEffect(() => {
    if (!enableIntersectionObserver || !containerRef.current) return;

    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsIntersecting(true);
          observer.disconnect();
        }
      },
      {
        threshold: 0.1,
        rootMargin: '50px'
      }
    );

    observer.observe(containerRef.current);

    return () => observer.disconnect();
  }, [enableIntersectionObserver]);

  // Handle image load
  const handleImageLoad = useCallback(() => {
    setImageError(false);
    onLoad?.();
  }, [onLoad]);

  // Handle image error
  const handleImageError = useCallback(async () => {
    setImageError(true);
    onError?.();

    // Don't try to regenerate thumbnails - this causes infinite loops when backend returns 404
    // The thumbnails should be generated by the backend when labels are created
    console.log(`üñºÔ∏è Thumbnail not available for label ${labelId}`);
    
    // IMPORTANT: Do not call refresh() here - it causes infinite loops!
  }, [onError, labelId]);

  // Manual refresh function
  const handleRefresh = useCallback(async () => {
    setImageError(false);
    setGenerating(true);
    try {
      await refresh();
    } finally {
      setGenerating(false);
    }
  }, [refresh]);

  // Determine what to render
  const renderContent = () => {
    // Loading state
    if (loading || generating) {
      return (
        <div className={`thumbnail-loading ${className}`}>
          <div className="loading-spinner">
            <RefreshCw className="animate-spin" size={16} />
          </div>
          {loading && <span className="loading-text">Loading...</span>}
          {generating && <span className="loading-text">Generating...</span>}
        </div>
      );
    }

    // Error state or no thumbnail
    if (error || imageError || !thumbnailUrl) {
      if (fallback) {
        return fallback;
      }

      return (
        <div className={`thumbnail-placeholder ${className}`}>
          <div className="placeholder-content">
            <Image size={24} className="placeholder-icon" aria-label="No preview available" />
            <span className="placeholder-text">No Preview</span>
            {generateOnError && (
              <button 
                onClick={handleRefresh}
                className="generate-btn"
                disabled={generating}
              >
                Generate
              </button>
            )}
          </div>
        </div>
      );
    }

    // Success state
    return (
      <NextImage
        ref={imgRef}
        src={thumbnailUrl}
        alt={alt || `Thumbnail for label ${labelId}`}
        className={`thumbnail-image ${className}`}
        onLoad={handleImageLoad}
        onError={handleImageError}
        width={200}
        height={150}
        style={{ objectFit: 'contain' }}
      />
    );
  };

  return (
    <div 
      ref={containerRef}
      className={`optimized-thumbnail ${size} ${loading ? 'loading' : ''} ${error ? 'error' : ''} ${className}`}
      style={{
        width: `${containerDimensions.width}px`,
        height: `${containerDimensions.height}px`,
        minWidth: `${containerDimensions.width}px`,
        minHeight: `${containerDimensions.height}px`,
      }}
    >
      {renderContent()}
    </div>
  );
};

// CSS-in-JS styles (you can move these to a CSS file)
const thumbnailStyles = `
  .optimized-thumbnail {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--color-gray-50);
    border-radius: 8px;
    overflow: hidden;
    transition: all 0.2s ease-in-out;
    /* Remove fixed sizes - now handled dynamically */
  }

  .thumbnail-image {
    width: 100%;
    height: 100%;
    object-fit: contain;
    transition: opacity 0.2s ease-in-out;
  }

  .thumbnail-loading,
  .thumbnail-placeholder {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: var(--color-gray-100);
    color: var(--color-gray-500);
    gap: 8px;
  }

  .loading-spinner {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .loading-text,
  .placeholder-text {
    font-size: 12px;
    font-weight: 500;
    text-align: center;
  }

  .placeholder-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }

  .placeholder-icon {
    opacity: 0.5;
  }

  .generate-btn {
    padding: 4px 8px;
    font-size: 10px;
    background: var(--color-primary-500);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
  }

  .generate-btn:hover {
    background: var(--color-primary-600);
  }

  .generate-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .optimized-thumbnail:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  .optimized-thumbnail.loading {
    animation: pulse 1.5s ease-in-out infinite;
  }
`;

// Inject styles (in a real app, these would be in a CSS file)
if (typeof document !== 'undefined') {
  const styleSheet = document.createElement('style');
  styleSheet.textContent = thumbnailStyles;
  document.head.appendChild(styleSheet);
}

// Export hook for programmatic thumbnail management
export const useThumbnailGenerator = () => {
  const generateThumbnail = useCallback(async (
    labelId: string, 
    canvasDataURL: string, 
    size: 'sm' | 'md' | 'lg' = 'md'
  ) => {
    try {
      const result = await OptimizedWorkspaceService.generateThumbnail(labelId, canvasDataURL, size);
      if (result) {
        console.log(`‚úÖ Generated thumbnail for label ${labelId} (${size})`);
        return result;
      }
      return null;
    } catch (error) {
      console.error(`‚ùå Failed to generate thumbnail for label ${labelId}:`, error);
      return null;
    }
  }, []);

  const batchGenerateThumbnails = useCallback(async (
    labelData: Array<{ labelId: string; canvasDataURL: string }>
  ) => {
    const results = await Promise.allSettled(
      labelData.map(({ labelId, canvasDataURL }) => 
        generateThumbnail(labelId, canvasDataURL)
      )
    );

    const successful = results.filter(r => r.status === 'fulfilled').length;
    console.log(`üìä Batch thumbnail generation: ${successful}/${results.length} successful`);

    return results;
  }, [generateThumbnail]);

  return {
    generateThumbnail,
    batchGenerateThumbnails
  };
};
